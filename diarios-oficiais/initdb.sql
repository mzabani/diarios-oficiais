create extension if not exists btree_gist;
create extension if not exists pg_trgm;

create table origemdiario (
    id int generated by default as identity primary key
    , nomeCompleto TEXT
    , cidade TEXT
    , estado TEXT
    , check ((nomecompleto is null) != (cidade is null) AND (cidade is null) = (estado is null))
);
create unique index on origemdiario (lower(cidade), lower(estado)) where nomeCompleto is null;
create unique index on origemdiario (lower(nomeCompleto)) where cidade is null and estado is null;

create table diario (
    id int generated by default as identity primary key
    , origemDiarioId int not null references origemdiario(id)
    , nome text not NULL
    , data date not null
    , unique (origemDiarioId, nome, data)
);

create table diarioabaixar (
    id int generated by default as identity primary KEY
    , diarioId int not null references diario(id)
    , inicioDownload timestamptz not null
    , unique (diarioId, inicioDownload)
);

create table conteudodiario (
    id int generated by default as identity primary KEY
    , conteudo text not null
    , md5sum text not null
    , unique (md5sum)
);

create table secaodiario (
    id int generated by default as identity primary KEY
    , conteudodiarioid int not null references conteudodiario(id)
    , ordem int not null
    , conteudo text not null
    , portuguese_conteudo_tsvector tsvector 
    , unique (conteudodiarioid, ordem)
);
CREATE INDEX ON secaodiario USING GIN (portuguese_conteudo_tsvector);
CREATE FUNCTION update_secaodiario_portuguese_conteudo_tsvector() RETURNS TRIGGER LANGUAGE plpgsql AS 
 $BODY$
   BEGIN
     UPDATE secaodiario SET portuguese_conteudo_tsvector = to_tsvector('portuguese', NEW.conteudo) WHERE id=NEW.id;
     RETURN NEW;
   END;
 $BODY$;
CREATE TRIGGER secaodiario_portuguese_conteudo_tsvector_on_insert AFTER INSERT ON secaodiario FOR EACH ROW EXECUTE PROCEDURE update_secaodiario_portuguese_conteudo_tsvector();
CREATE TRIGGER secaodiario_portuguese_conteudo_tsvector_on_update AFTER UPDATE ON secaodiario FOR EACH ROW WHEN (OLD.conteudo != NEW.conteudo) EXECUTE PROCEDURE update_secaodiario_portuguese_conteudo_tsvector();
-- ^ Um índice sobre a expressão to_tsvector('portuguese', conteudo) infelizmente não é usado em buscas Full Text por conta de palavras longas demais para serem indexadas.. como coluna isso não acontece

create table diarioabaixartoconteudodiario (
    id int generated by default as identity primary key
    , diarioabaixarId int not null references diarioabaixar(id)
    , conteudodiarioId int not null references conteudodiario(id)
    , unique (diarioabaixarId, conteudodiarioId)
);

create table statusdownloaddiario (
    id int generated by default as identity primary KEY
    , diarioABaixarId int not null references diarioabaixar(id)
    , url text not null
    , ordem int not null
    , inicioDownload timestamptz not NULL
    , terminoDownload timestamptz check (terminoDownload is null or terminoDownload >= inicioDownload)
    , momentoErro timestamptz check (momentoErro is null or momentoErro >= inicioDownload)
    , check (terminoDownload is null and momentoErro is null or (terminoDownload is null) != (momentoErro is null))
    , unique (diarioABaixarId, ordem)
    , unique (diarioABaixarId, url)
);

create table downloadterminado (
    id int generated by default as identity primary KEY
    , statusDownloadDiarioId int not null references statusdownloaddiario(id)
    , momentoTermino timestamptz not null
    , md5sum text not null
    , filePath text not null
    , unique (statusDownloadDiarioId)
);

create table nomeencontrado (
    id int generated by default as identity primary KEY
    , conteudodiarioid int not null references conteudodiario(id)
    , lowerednome text not NULL check (lowerednome != '' and lowerednome = lower(lowerednome) and trim(lowerednome) = lowerednome)
    , posicao int not null check (posicao >= 0)
    , unique (lowerednome, conteudodiarioid, posicao)
);
create index on nomeencontrado(lowerednome);

create table usuarios (
    id int generated by default as identity primary key
    , facebook_id bigint
    , email text not null check (email != '' and trim(email) = email)
    , nome_completo text not null check (nome_completo != '' and trim(nome_completo) = nome_completo));
create unique index on usuarios (lower(email));

create table usuariosencontrados (
    id int generated by default as identity primary key
    , conteudo_diario_id int not null references conteudodiario(id)
    , usuario_id int not null references usuarios(id)
    , idx int not null check (idx >= 0)
    , nome_encontrado text not null check (nome_encontrado != '' and trim(nome_encontrado) = nome_encontrado)
    , unique (conteudo_diario_id, usuario_id, idx));

create table usuariosbuscados (
    id int generated by default as identity primary key
    , conteudo_diario_id int not null references conteudodiario(id)
    , usuario_id int not null references usuarios(id)
    , busca_terminada_em timestamptz not null
    , unique (conteudo_diario_id, usuario_id, busca_terminada_em));

create table assinaturas (
    id int generated by default as identity primary KEY
    , usuario_id int not null references usuarios(id)
    , desde date not null
    , ate date not null check (ate >= desde)
    , exclude using gist (usuario_id WITH =, daterange(desde, ate, '[]') WITH &&)
);

-- Ideia: poder buscar CPFs, CNPJs, valores em R$, datas e horários ou outras coisas interessantes.
-- Queremos tratar valores em R$ como números para permitir buscas de (>= | == | <= | etc.)
-- Queremos tratar CPFs e CNPJs como texto pois não há comparador útil além da igualdade e semelhança (== | levenshtein)
-- Queremos tratar datas e horários como datas e horários para permitir buscas de (>= | == | <= | etc.)
create table tokens_numericos (
    id int generated by default as identity primary KEY
    , valor_numerico decimal not null
    , conteudo_diario_id int not null references conteudodiario(id)
    , tipo text not null -- Isso aqui seria 'R$', 'EUR', 'Idade' etc.
    , inicio int not null check (inicio >= 0)
    , comprimento int not null check (comprimento > 0)
);
create index on tokens_numericos (valor_numerico);
create unique index on tokens_numericos (conteudo_diario_id, tipo, inicio);

create table tokens_texto (
    id int generated by default as identity primary KEY
    , valor_texto text not null
    , conteudo_diario_id int not null references conteudodiario(id)
    , tipo text not null -- Isso aqui seria 'CPF', 'CNPJ' etc.
    , inicio int not null check (inicio >= 0)
    , comprimento int not null check (comprimento > 0)
);
create index on tokens_texto (valor_texto);
create unique index on tokens_texto (conteudo_diario_id, tipo, inicio);

create table tokens_data (
    id int generated by default as identity primary KEY
    , valor_data date not null
    , conteudo_diario_id int not null references conteudodiario(id)
    , inicio int not null check (inicio >= 0)
    , comprimento int not null check (comprimento > 0)
);
create index on tokens_data (valor_data);
create unique index on tokens_data (conteudo_diario_id, inicio);

insert into origemdiario (id, cidade, estado) values (1, 'Campinas', 'SP') on conflict do nothing;
insert into origemdiario (id, cidade, estado) values (2, 'Sumaré', 'SP') on conflict do nothing;